<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/paper-button/paper-button.html">
<link rel="import" href="../bower_components/paper-slider/paper-slider.html">
<link rel="import" href="../bower_components/core-icons/av-icons.html">
<link rel="import" href="../bower_components/core-signals/core-signals.html">
<link rel="import" href="controller-bar-media-element.html">

<link href='http://fonts.googleapis.com/css?family=Roboto:400,100' rel='stylesheet' type='text/css'>

<polymer-element name="chromecast-controller-bar">
  <template>
    <style>
      :host {
        width:390px;
        height:50px;
        position:fixed;
        bottom: -50px;
        right: 100px;
        background-color: #555555;
        z-index: 10000;
        transition: .3s ease-in-out;
      }

      #controller_bar {
        padding: 0px 10px;
        display: flex;
        flex-direction:row;
        justify-content:space-around;
        align-items:center;
        height:50px;
      }

      label.title {
        display: flex;
        flex-grow: 1;
        font-family: 'Roboto', sans-serif;
        font-weight: 400;
        font-size:1.3em;
        color: #ffffff;
      }

      core-icon[icon="av:play-arrow"] {
        height: 39px;
        width: 39px;
        color: #ffffff;
      }

      core-icon[icon="av:play-arrow"]:hover {
        color: #4F7DC9;
      }

      core-icon[icon="av:pause"] {
        height: 39px;
        width: 39px;
        color: #ffffff;
      }

      core-icon[icon="av:pause"]:hover {
        color: #4F7DC9;
      }

      #button_play_pause {
        height: 40px;
        min-width: 0px;
        display: flex;
        flex-grow: 1;
        justify-content: center;
      }

      #label_time {
        order: 4;
        display: flex;
        flex-grow: 2;
        color: #ffffff;
        font-family: 'Roboto', sans-serif;
        font-weight: 100;
        width: 3em;
      }

      #slider_progress {
        display:flex;
        flex-grow:7;
        width:100px;
      }

      #slider_progress::shadow #sliderKnobInner,
      #slider_progress::shadow #sliderBar::shadow #activeProgress {
        background-color: #4F7DC9;
      }

      #content_bar {
        display: flex;
        flex-direction: column;
        align-content: space-around;
        justify-content: center;
      }

      #content_window {
        max-height:300px;
        width:100%;
        overflow-y:scroll;
      }
      .top-border {
        border-top: 2px solid #000000;
      }

      .bottom-border {
        border-bottom: 2px solid #000000;
      }

    </style>
    <div id="controller_bar">
      <label class="title">Queue</label>
      <paper-button id="button_play_pause">
        <core-icon id="icon_play_pause"
                   icon="av:play-arrow"></core-icon>
      </paper-button>
      <paper-slider id="slider_progress" immediateValue="{{ sliderValue }}"></paper-slider>
      <label id="label_time">
        {{ castTimeRemaining }}
      </label>
    </div>
    <div id="content_window">
      <div id="content_bar">
        <template repeat="{{ item in queueItems }}">
          <controller-bar-media-element media="{{ item }}" mediaStatus="{{ mediaStatus }}" on-dragover="{{ dragoverHandler }}" on-drop="{{ dropHandler }}" on-dragstart="{{ dragstartHandler }}" on-dragleave="{{ dragleaveHandler }}" draggable="true"></controller-bar-media-element>
        </template>
      </div>
    </div>
    </template>
    <script>
      Polymer("chromecast-controller-bar", {
        publish: {
          mediaStatus: null
        },
        castTimeRemaining: '00:00:00',
        itemHeight: 60,
        sliderValue: 0,
        intervalId: null,
        currTime: null,
        prevTime: null,
        queueItems: [],
        observe: {
          'mediaStatus.castMedia.media.contentId': 'mediaMatchObserver',
          'mediaStatus.localMedia.url': 'mediaMatchObserver',
          'mediaStatus.castMedia.playerState': 'playerStateObserver',
          'mediaStatus.castMedia.currentTime': 'currentTimeObserver',
          'mediaStatus.castMedia.items': 'queueItemObserver'
        },
        ready: function() {
          this.$.button_play_pause.addEventListener('click', function (event) {
            if (this.mediaStatus.castMedia.playerState != chrome.cast.media.PlayerState.PLAYING) {
              this.mediaStatus.play(cast.MediaStatus.SENDER.CASTCONTROLLER);
            } else {
              this.mediaStatus.pause(cast.MediaStatus.SENDER.CASTCONTROLLER);
            }
          }.bind(this));
          this.$.slider_progress.addEventListener('change', this.sliderUpdate.bind(this));
          this.addEventListener('click', function(event) {
            event.stopPropagation();
          });
        },
        /**
         * Observe the chromecast player state and update
         * @param oldVal {chrome.cast.media.PlayerState}
         * @param newVal {chrome.cast.media.PlayerState}
         */
        playerStateObserver: function(oldVal,newVal) {
          if (newVal === chrome.cast.media.PlayerState.PLAYING) {
            this.$.icon_play_pause.setAttribute('icon', 'av:pause');
            if(this.intervalId == null) {
              this.intervalId = window.setInterval(function(){
                var currTime = new Date();
                if(this.prevTime == null) {
                  this.prevTime = new Date();
                }
                var deltaS = (currTime - this.prevTime)/1000;
                this.mediaStatus.castMedia.currentTime += deltaS;
                this.prevTime = currTime;
              }.bind(this),1000);
            }
          } else {
            this.$.icon_play_pause.setAttribute('icon', 'av:play-arrow');
            window.clearInterval(this.intervalId);
            this.intervalId = null;
            this.prevTime = null;
          }
        },
        sliderUpdate: function (newVal) {
          if(this.mediaStatus.hasCastMedia()) {
            var duration = this.mediaStatus.castMedia.media.duration;
            var time = (this.sliderValue / 100) * duration;
            this.mediaStatus.seek(time, cast.MediaStatus.SENDER.CASTCONTROLLER);
          }
        },
        currentTimeObserver: function(oldVal, newVal) {
          if (this.mediaStatus.hasCastMedia()) {
            var duration = this.mediaStatus.castMedia.media.duration;
            var currentTime = this.mediaStatus.castMedia.currentTime;
            this.castTimeRemaining = cast.Media.secondsToHHMMSS(duration - currentTime);
            this.sliderValue = Math.round(currentTime / duration * 100);
          }
        },
        mediaMatchObserver: function(oldVal, newVal) {
          if (!this.mediaStatus.isMediaMatch()
              || (this.mediaStatus.castMedia.items != null
              && this.mediaStatus.castMedia.items.length > 1)) {
            this.style.transform = 'translateY(' + (-50 - this.itemHeight * Math.min(5,this.queueItems.length))
            + 'px)';
          } else {
            this.style.transform = '';
          }
        },
        queueItemObserver: function(oldVal, newVal) {
          if (this.mediaStatus.castMedia.items != null
              && this.queueItems !== this.mediaStatus.castMedia.items) {
            this.queueItems = this.mediaStatus.castMedia.items;
          }
          this.mediaMatchObserver();
        },
        dragoverHandler: function(event, detail, sender) {
          event.preventDefault();

          var mouseY = event.clientY + document.body.scrollTop
              + document.documentElement.scrollTop;

          var currElement = sender.getBoundingClientRect();

          if (mouseY < currElement.top + currElement.height/2) {
            sender.classList.add('top-border');
            sender.classList.remove('bottom-border');
          } else {
            sender.classList.add('bottom-border');
            sender.classList.remove('top-border');
          }
        },
        dropHandler: function(event, detail, sender) {
          console.log('dropped: ' + event.dataTransfer.getData("text/plain") + 'on ' + sender.media.itemId);
          sender.classList.remove('bottom-border');
          sender.classList.remove('top-border');

          var mouseY = event.clientY + document.body.scrollTop
          var currElement = sender.getBoundingClientRect();
          var index = sender.media.itemId;
          if (mouseY >= currElement.top + currElement.height/2) {
            index++;
          }

          this.mediaStatus.queueMoveItemToNewIndex(parseInt(event.dataTransfer.getData("text/plain")),
            index);
        },
        dragleaveHandler: function(event, detail, sender) {
          sender.classList.remove('bottom-border');
          sender.classList.remove('top-border');
        },
        dragstartHandler: function(event, detail, sender) {
          event.dataTransfer.setData('text/plain', sender.media.itemId);
        }
      });
    </script>
</polymer-element>
